"""
Proof of Discrete Log Equivalence (PoDLE) for JoinMarket.

PoDLE is used to prevent sybil attacks in JoinMarket by requiring takers
to prove ownership of a UTXO without revealing which UTXO until after
the maker commits to participate.

This module provides both generation (for takers) and verification (for makers)
of PoDLE proofs.

Protocol flow:
1. Taker generates commitment C = H(P2) where P2 = k*J (k = private key, J = NUMS point)
2. Taker sends commitment C to maker
3. Maker accepts and sends pubkey
4. Taker reveals P, P2, sig, e as the "revelation"
5. Maker verifies: P = k*G and P2 = k*J (same k)

Reference: https://gist.github.com/AdamISZ/9cbba5e9408d23813ca8
Reference: joinmarket-clientserver/src/jmclient/podle.py
"""

from __future__ import annotations

import hashlib
import secrets
from dataclasses import dataclass
from typing import Any

from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import ec
from loguru import logger

# secp256k1 curve order
SECP256K1_N = int("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16)
# secp256k1 field prime
SECP256K1_P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F

# Generator point G (compressed)
G_COMPRESSED = bytes.fromhex("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")

# Precomputed NUMS (Nothing Up My Sleeve) points J_0 to J_9
# These are generated deterministically and cannot be derived from G
PRECOMPUTED_NUMS = {
    0: bytes.fromhex("0296f47ec8e6d6a9c3379c2ce983a6752bcfa88d46f2a6ffe0dd12c9ae76d01a1f"),
    1: bytes.fromhex("023f9976b86d3f1426638da600348d96dc1f1eb0bd5614cc50db9e9a067c0464a2"),
    2: bytes.fromhex("023745b000f6db094a794d9ee08637d714393cd009f86087438ac3804e929bfe89"),
    3: bytes.fromhex("023346660dcb1f8d56e44d23f93c3ad79761cdd5f4972a638e9e15517832f6a165"),
    4: bytes.fromhex("02ec91c86964dcbb077c8193156f3cfa91476d5adfcfcf64913a4b082c75d5bca7"),
    5: bytes.fromhex("02bbc5c4393395a38446e2bd4d638b7bfd864afb5ffaf4bed4caf797df0e657434"),
    6: bytes.fromhex("02967efd39dc59e6f060bf3bd0080e8ecf4a22b9d1754924572b3e51ce2cde2096"),
    7: bytes.fromhex("02cfce8a7f9b8a1735c4d827cd84e3f2a444de1d1f7ed419d23c88d72de341357f"),
    8: bytes.fromhex("0206d6d6b1d88936bb6013ae835716f554d864954ea336e3e0141fefb2175b82f9"),
    9: bytes.fromhex("021b739f21b981c2dcbaf9af4d89223a282939a92aee079e94a46c273759e5b42e"),
}


class PoDLEError(Exception):
    """PoDLE generation or verification error."""

    pass


@dataclass
class PoDLECommitment:
    """PoDLE commitment data generated by taker."""

    commitment: bytes  # H(P2) - 32 bytes
    p: bytes  # Public key P = k*G - 33 bytes compressed
    p2: bytes  # Commitment point P2 = k*J - 33 bytes compressed
    sig: bytes  # Schnorr signature s - 32 bytes
    e: bytes  # Challenge e - 32 bytes
    utxo: str  # UTXO reference "txid:vout"
    index: int  # NUMS point index used

    def to_revelation(self) -> dict[str, str]:
        """Convert to revelation format for sending to maker."""
        return {
            "P": self.p.hex(),
            "P2": self.p2.hex(),
            "sig": self.sig.hex(),
            "e": self.e.hex(),
            "utxo": self.utxo,
        }

    def to_commitment_str(self) -> str:
        """Get commitment as hex string."""
        return self.commitment.hex()


# ==============================================================================
# EC Point Operations
# ==============================================================================


def get_nums_point(index: int) -> ec.EllipticCurvePublicKey:
    """Get Nothing-Up-My-Sleeve (NUMS) generator point J for given index."""
    if index not in PRECOMPUTED_NUMS:
        raise PoDLEError(f"NUMS point index {index} not supported (max 9)")

    point_bytes = PRECOMPUTED_NUMS[index]
    return ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), point_bytes)


def scalar_mult_g(scalar: int) -> ec.EllipticCurvePublicKey:
    """Multiply generator G by scalar."""
    private_key = ec.derive_private_key(scalar % SECP256K1_N, ec.SECP256K1())
    return private_key.public_key()


def point_mult(scalar: int, point: ec.EllipticCurvePublicKey) -> ec.EllipticCurvePublicKey:
    """Multiply EC point by scalar using double-and-add algorithm."""
    nums = point.public_numbers()
    x, y = nums.x, nums.y

    result_x: int | None = None
    result_y: int | None = None

    scalar = scalar % SECP256K1_N
    curr_x, curr_y = x, y

    while scalar > 0:
        if scalar & 1:
            if result_x is None or result_y is None:
                result_x, result_y = curr_x, curr_y
            else:
                result_x, result_y = _point_add(result_x, result_y, curr_x, curr_y)

        curr_x, curr_y = _point_double(curr_x, curr_y)
        scalar >>= 1

    if result_x is None or result_y is None:
        raise PoDLEError("Scalar multiplication resulted in point at infinity")

    return ec.EllipticCurvePublicNumbers(result_x, result_y, ec.SECP256K1()).public_key()


def point_add(
    p1: ec.EllipticCurvePublicKey, p2: ec.EllipticCurvePublicKey
) -> ec.EllipticCurvePublicKey:
    """Add two EC points."""
    p1_nums = p1.public_numbers()
    p2_nums = p2.public_numbers()

    x1, y1 = p1_nums.x, p1_nums.y
    x2, y2 = p2_nums.x, p2_nums.y

    x3, y3 = _point_add(x1, y1, x2, y2)
    return ec.EllipticCurvePublicNumbers(x3, y3, ec.SECP256K1()).public_key()


def _point_add(x1: int, y1: int, x2: int, y2: int) -> tuple[int, int]:
    """Add two points on secp256k1."""
    if x1 == x2 and y1 == y2:
        return _point_double(x1, y1)

    if x1 == x2:
        raise ValueError("Points are inverses")

    p = SECP256K1_P
    s = ((y2 - y1) * pow(x2 - x1, p - 2, p)) % p
    x3 = (s * s - x1 - x2) % p
    y3 = (s * (x1 - x3) - y1) % p
    return x3, y3


def _point_double(x: int, y: int) -> tuple[int, int]:
    """Double a point on secp256k1."""
    p = SECP256K1_P
    s = ((3 * x * x) * pow(2 * y, p - 2, p)) % p
    x3 = (s * s - 2 * x) % p
    y3 = (s * (x - x3) - y) % p
    return x3, y3


def point_to_bytes(point: ec.EllipticCurvePublicKey) -> bytes:
    """Convert EC point to compressed bytes."""
    return point.public_bytes(
        encoding=serialization.Encoding.X962,
        format=serialization.PublicFormat.CompressedPoint,
    )


# ==============================================================================
# PoDLE Generation (Taker side)
# ==============================================================================


def generate_podle(
    private_key_bytes: bytes,
    utxo_str: str,
    index: int = 0,
) -> PoDLECommitment:
    """
    Generate a PoDLE commitment for a UTXO.

    The PoDLE proves that the taker owns the UTXO without revealing
    the private key. It creates a zero-knowledge proof that:
    P = k*G and P2 = k*J have the same discrete log k.

    Args:
        private_key_bytes: 32-byte private key
        utxo_str: UTXO reference as "txid:vout"
        index: NUMS point index (0-9)

    Returns:
        PoDLECommitment with all proof data
    """
    if len(private_key_bytes) != 32:
        raise PoDLEError(f"Invalid private key length: {len(private_key_bytes)}")

    if index not in PRECOMPUTED_NUMS:
        raise PoDLEError(f"Invalid NUMS index: {index}")

    # Get private key as integer
    k = int.from_bytes(private_key_bytes, "big")
    if k == 0 or k >= SECP256K1_N:
        raise PoDLEError("Invalid private key value")

    # Calculate P = k*G (standard public key)
    p_point = scalar_mult_g(k)
    p_bytes = point_to_bytes(p_point)

    # Get NUMS point J
    j_point = get_nums_point(index)

    # Calculate P2 = k*J
    p2_point = point_mult(k, j_point)
    p2_bytes = point_to_bytes(p2_point)

    # Generate commitment C = H(P2)
    commitment = hashlib.sha256(p2_bytes).digest()

    # Generate Schnorr-like proof
    # Choose random nonce k_proof
    k_proof = int.from_bytes(secrets.token_bytes(32), "big") % SECP256K1_N
    if k_proof == 0:
        k_proof = 1

    # Kg = k_proof * G
    kg_point = scalar_mult_g(k_proof)
    kg_bytes = point_to_bytes(kg_point)

    # Kj = k_proof * J
    kj_point = point_mult(k_proof, j_point)
    kj_bytes = point_to_bytes(kj_point)

    # Challenge e = H(Kg || Kj || P || P2)
    e_bytes = hashlib.sha256(kg_bytes + kj_bytes + p_bytes + p2_bytes).digest()
    e = int.from_bytes(e_bytes, "big") % SECP256K1_N

    # Response s = k_proof - e * k (mod n)
    s = (k_proof - e * k) % SECP256K1_N
    s_bytes = s.to_bytes(32, "big")

    logger.debug(
        f"Generated PoDLE for {utxo_str} using NUMS index {index}, "
        f"commitment={commitment.hex()[:16]}..."
    )

    return PoDLECommitment(
        commitment=commitment,
        p=p_bytes,
        p2=p2_bytes,
        sig=s_bytes,
        e=e_bytes,
        utxo=utxo_str,
        index=index,
    )


# ==============================================================================
# PoDLE Verification (Maker side)
# ==============================================================================


def verify_podle(
    p: bytes,
    p2: bytes,
    sig: bytes,
    e: bytes,
    commitment: bytes,
    index_range: range = range(10),
) -> tuple[bool, str]:
    """
    Verify PoDLE proof.

    Verifies that P and P2 have the same discrete log (private key)
    without revealing the private key itself.

    Args:
        p: Public key bytes (33 bytes compressed)
        p2: Commitment public key bytes (33 bytes compressed)
        sig: Signature s value (32 bytes)
        e: Challenge e value (32 bytes)
        commitment: sha256(P2) commitment (32 bytes)
        index_range: Allowed NUMS indices to try

    Returns:
        (is_valid, error_message)
    """
    try:
        if len(p) != 33:
            return False, f"Invalid P length: {len(p)}, expected 33"
        if len(p2) != 33:
            return False, f"Invalid P2 length: {len(p2)}, expected 33"
        if len(sig) != 32:
            return False, f"Invalid sig length: {len(sig)}, expected 32"
        if len(e) != 32:
            return False, f"Invalid e length: {len(e)}, expected 32"
        if len(commitment) != 32:
            return False, f"Invalid commitment length: {len(commitment)}, expected 32"

        expected_commitment = hashlib.sha256(p2).digest()
        if commitment != expected_commitment:
            return False, "Commitment does not match H(P2)"

        p_point = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), p)
        p2_point = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), p2)

        s_int = int.from_bytes(sig, "big")
        e_int = int.from_bytes(e, "big")

        if s_int >= SECP256K1_N or e_int >= SECP256K1_N:
            return False, "Signature values out of range"

        # sg = s * G
        sg = scalar_mult_g(s_int)

        for index in index_range:
            try:
                j = get_nums_point(index)

                # Kg = s*G + e*P
                ep = point_mult(e_int, p_point)
                kg = point_add(sg, ep)

                # Kj = s*J + e*P2
                sj = point_mult(s_int, j)
                ep2 = point_mult(e_int, p2_point)
                kj = point_add(sj, ep2)

                kg_bytes = point_to_bytes(kg)
                kj_bytes = point_to_bytes(kj)

                e_check = hashlib.sha256(kg_bytes + kj_bytes + p + p2).digest()

                if e_check == e:
                    logger.debug(f"PoDLE verification successful at index {index}")
                    return True, ""

            except Exception as ex:
                logger.debug(f"PoDLE verification failed at index {index}: {ex}")
                continue

        return False, f"PoDLE verification failed for all indices in {index_range}"

    except Exception as ex:
        logger.error(f"PoDLE verification error: {ex}")
        return False, f"Verification error: {ex}"


# ==============================================================================
# Revelation Parsing (Maker side)
# ==============================================================================


def parse_podle_revelation(revelation: dict[str, Any]) -> dict[str, Any] | None:
    """
    Parse and validate PoDLE revelation structure.

    Expected format from taker:
    {
        'P': <hex string>,
        'P2': <hex string>,
        'sig': <hex string>,
        'e': <hex string>,
        'utxo': <txid:vout string>
    }

    Returns parsed structure with bytes or None if invalid.
    """
    try:
        required_fields = ["P", "P2", "sig", "e", "utxo"]
        for field in required_fields:
            if field not in revelation:
                logger.warning(f"Missing required field in PoDLE revelation: {field}")
                return None

        p_bytes = bytes.fromhex(revelation["P"])
        p2_bytes = bytes.fromhex(revelation["P2"])
        sig_bytes = bytes.fromhex(revelation["sig"])
        e_bytes = bytes.fromhex(revelation["e"])

        utxo_parts = revelation["utxo"].split(":")
        if len(utxo_parts) != 2:
            logger.warning(f"Invalid UTXO format: {revelation['utxo']}")
            return None

        txid = utxo_parts[0]
        vout = int(utxo_parts[1])

        return {
            "P": p_bytes,
            "P2": p2_bytes,
            "sig": sig_bytes,
            "e": e_bytes,
            "txid": txid,
            "vout": vout,
        }

    except Exception as e:
        logger.error(f"Failed to parse PoDLE revelation: {e}")
        return None


def deserialize_revelation(revelation_str: str) -> dict[str, Any] | None:
    """
    Deserialize PoDLE revelation from wire format.

    Format: P|P2|sig|e|utxo (pipe-separated hex strings)
    """
    try:
        parts = revelation_str.split("|")
        if len(parts) != 5:
            logger.warning(f"Invalid revelation format: expected 5 parts, got {len(parts)}")
            return None

        return {
            "P": parts[0],
            "P2": parts[1],
            "sig": parts[2],
            "e": parts[3],
            "utxo": parts[4],
        }

    except Exception as e:
        logger.error(f"Failed to deserialize PoDLE revelation: {e}")
        return None


def serialize_revelation(commitment: PoDLECommitment) -> str:
    """
    Serialize PoDLE revelation to wire format.

    Format: P|P2|sig|e|utxo (pipe-separated hex strings)
    """
    return "|".join(
        [
            commitment.p.hex(),
            commitment.p2.hex(),
            commitment.sig.hex(),
            commitment.e.hex(),
            commitment.utxo,
        ]
    )
